[
    {
        "Id": 1,
        "Subject": "OS",
        "Difficulty": 1,
        "Question": "페이지 교체 알고리즘에 따른 페이지 폴트 방식의 설명 중 올바르지 않은 것은",
        "Code": "",
        "Answers": [
            "FIFO : 메모리가 할당된 순서대로 페이지를 교체",
            "LFU : 사용 빈도가 가장 많은 페이지를 교체",
            "NUR : 최근에 사용하지 않은 페이지를 교체",
            "LRU : 가장 오랫동안 참조되지 않은 페이지를 교체",
            "없음"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 2,
        "Subject": "DB",
        "Difficulty": 0,
        "Question": "DBMS의 Index에 대한 설명 중 틀린 것은",
        "Code": "",
        "Answers": [
            "항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데 빠르다",
            "새로운 값을 추가하거나 삭제, 수정 하는데 빠르다",
            "없음"
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 3,
        "Subject": "DB",
        "Difficulty": 0,
        "Question": "트랜잭션이 만족해야하는 특성 중 올바르지 않은 것은?",
        "Code": "",
        "Answers": [
            "원자성(Atomicity)",
            "일관성(Consistency)",
            "고립성(Isolation)",
            "지속성(Durability)",
            "없음"
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 4,
        "Subject": "Algorithm",
        "Difficulty": 1,
        "Question": "Time Complexity가 같은 것끼리 짝지어진 것은?",
        "Code": "",
        "Answers": [
            "Bubble Sort & Merge Sort",
            "Bubble Sort & Heap Sort",
            "Bubble Sort & Selection Sort",
            "없음"
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 5,
        "Subject": "DataStructure",
        "Difficulty": 0,
        "Question": "Stack을 설명하는 것으로 올바른 것은?",
        "Code": "",
        "Answers": [
            "Last In First Out",
            "First In First Out",
            "없음"
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 6,
        "Subject": "Development common sense",
        "Difficulty": 1,
        "Question": "객체 지향적 설계 원칙 중 올바르지 않은 것은?",
        "Code": "",
        "Answers": [
            "클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.",
            "확장에는 닫혀 있어야 하고 변경에는 열려 있어야 한다.",
            "상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.",
            "인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.",
            "고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다."
            
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 7,
        "Subject": "Network",
        "Difficulty": 0,
        "Question": "다음 빈칸에 들어갈 말은",
        "Code": " [  ] 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url 에 담겨서 전송된다. 때문에 url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. ",
        "Answers": [
            "GET",
            "POST",
            "없음"
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 8,
        "Subject": "OS",
        "Difficulty": 0,
        "Question": "Process Control Block에 저장되는 정보 중 올바르지 않은 것은?",
        "Code": "",
        "Answers": [
            "프로세스 식별번호",
            "프로세스 상태",
            "프로세스의 우선순위, 스케줄 큐에 대한 포인터 등",
            "없음"
        ],
        "Reference": "https://github.com/JaeYeopHan/Interview_Question_for_Beginner"
    },
    {
        "Id": 9,
        "Subject": "Web",
        "Difficulty": 0,
        "Question": "HTTP status의 코드, 이름, 의미가 올바르게 짝지어진 것은?",
        "Code": "",
        "Answers": [
            "200, Create, 생성 성공(POST)",
            "200, OK, 생성 성공(POST)",
            "201, Create, 생성 성공(POST)",
            "201, OK, 생성 성공(POST)",
            "없음"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 10,
        "Subject": "Web",
        "Difficulty": 0,
        "Question": "Cookie와 Session의 설명 중 올바르지 못한 것은?",
        "Code": "",
        "Answers": [
            "Cookie의 저장위치는 Client다",
            "Cookie의 개수 제한은 없다",
            "Session의 만료시점은 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없을 경우이다",
            "없음"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 11,
        "Subject": "Network",
        "Difficulty": 1,
        "Question": "3 way handshake 순서 설명 중 올바르지 못한 것은?",
        "Code": "",
        "Answers": [
            "1. 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence : x)",
            "2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (sequence : y, ACK : x + 1)",
            "3. 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄",
            "없음"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 12,
        "Subject": "Language",
        "Difficulty": 0,
        "Question": "JAVA 메모리 영역 설명 중 올바르게 짝지어진 것은?",
        "Code": "",
        "Answers": [
            "스택 : 바이트 코드, 전역 변수, static 변수",
            "메소드 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시에 메모리 할당)",
            "힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당",
            "없음"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 13,
        "Subject": "OS",
        "Difficulty": 0,
        "Question": "교착상태 4가지 조건 중 올바르지 못한 것은?",
        "Code": "",
        "Answers": [
            "상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함",
            "점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림",
            "비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음",
            "순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음",
            "없음"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 14,
        "Subject": "Data Structure",
        "Difficulty": 0,
        "Question": "해시테이블에서 중복된 값 충돌에 대한 해결 방안 중 올바르지 않은 것은",
        "Code": "",
        "Answers": [
            "선형 조사법: 충돌이 일어난 항목을 해시 테이블의 다른 위치에 저장",
            "이차 조사법: 선형 조사법에서 발생하는 집적화 문제를 완화시켜 줌",
            "이중 해시법: 충돌로 인해 비어있는 버킷을 찾을 때 추가적인 해시 함수 h'()를 사용하는 방식",
            "체이닝: 각 버킷을 고정된 개수의 슬롯 대신, 유동적 크기를 갖는 연결리스트로 구성하여 충돌 뿐만 아니라 오버플로우 문제도 해결 가능",
            "없음"
            
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
    {
        "Id": 15,
        "Subject": "Algorithm",
        "Difficulty": 0,
        "Question": "아래 코드에 알맞는 Algorithm은?",
        "Code": "void Sort(int[] arr) {\n\tint temp = 0;\n\tfor(int i = 0; i < arr.length; i++) {\n\t\tfor(int j= 1 ; j < arr.length-i; j++) {\n\t\t\tif(arr[j-1] > arr[j]) {\n\t\t\t\ttemp = arr[j-1];\n\t\t\t\tarr[j-1] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.println(Arrays.toString(arr));\n}",
        "Answers": [
            "Insertion Sort",
            "Quick Sort",
            "Bubble Sort",
            "Merge Sort"
        ],
        "Reference": "https://github.com/gyoogle/tech-interview-for-developer"
    },
	{
    "Id": 16,
    "Subject": "Database",
    "Difficulty": 1,
    "Question": "다음 중 맞는 설명을 고르세요.",
    "Code": "",
    "Answers": [
	    "table의 각 column에 인덱스를 많이 걸면 걸수록 좋다.",
        "1:N 관계를 가지고 있는 users, languages 테이블이 있을 때, ORM을 사용하여 user가 사용하는 모든 languages를 찾으려고 한다. N+1 번의 query가 최선이다.",
        "live로 서비스 중인 DB에서 테이블의 row의 수가 10M 이상인 테이블을 삭제하려고 할 때, 다른 테이블에서 해당 테이블에 대한 foreign key constraints가 존재한다. 삭제시에 CASCADE 옵션을 사용하면 안전하다.",
        "consistent hashing으로 구현된 key-value data store의 N개의 node 중 한 개가 down 되었을 때, 1/N개의 item만 rebalancing 된다."
		],
    "Reference": "zzerjae's brain"
	},
	{
    "Id": 17,
    "Subject": "Cloud",
    "Difficulty": 1,
    "Question": "다음 중 맞는 설명을 고르세요.",
    "Code": "",
    "Answers": [
	    "퍼블릭 클라우드를 사용할 때, 인프라 리소스는 가능한 적은 수의 가용 영역에 배포하는 것이 안전하다.",
        "load balancer, VPN, bastion host 중에서, 서비스에 대한 요청이 증가할 때 도입하는 것은 VPN이다.",
        "퍼블릭 클라우드는 기본적으로 사용한 단위시간 만큼 요금을 지불하기 때문에 초기 도입 비용이 적거나 없다.",
        "하나의 서버 인스턴스에 api server, database, storage를 구성하는 것이 분산하는 것보다 안전하다."
		],
    "Reference": "zzerjae's brain"
	},
	{
    "Id": 18,
    "Subject": "Queue",
    "Difficulty": 1,
    "Question": "다음 중 정확성을 일부 포기하면서도 가장 성능이 좋은 message 전달 전략은 무엇일까요?",
    "Code": "",
    "Answers": [
        "적어도 한번 (at least once)",
        "최대 한번 (at most once)",
        "정확히 한번 (exactly once)"
		],
    "Reference": "zzerjae's brain"
	},
	{
    "Id": 19,
    "Subject": "devops",
    "Difficulty": 1,
    "Question": "다음 중 적절한 설명을 고르세요.",
    "Code": "",
    "Answers": [
        "terraform과 같은 Infrastructure as a code 툴은 API 자동화를 통해 명령형으로 인프라를 관리하는 것이 목적이다.",
        "ruby나 python과 같은 script 언어로 서버 프로그램을 개발하는 것이 Go와 같이 compile 언어를 사용했을 때보다 컨테이너를 사용한 배포 환경에 유리하다.",
        "docker를 사용한 개발이 각광받게 된 이유는 서버에 새로운 코드를 배포하거나, 문제가 있는 서버를 내려야 할 때 손 쉽게 기존의 컨테이너는 버리고 새로운 컨테이너를 배포할 수 있기 때문이다.",
        "canary 배포 전략은 A/B 두 세트의 인프라를 준비하고, A에서 실제 서비스를 하다가 새로운 배포 시에 B 서버를 준비하여 B에서 서비스를 하는 것이다."
		],
    "Reference": "zzerjae's brain"
	}
]    
